# Sorting Algorithms

## Overview
The `codebrush.Sort` folder contains various sorting algorithms, categorized into different types based on their approach and efficiency.

## List of Sorting Algorithms

### 1. **Basic Sorting Algorithms**
- **Bubble codebrush.Sort**
- **Insertion codebrush.Sort**
- **Selection codebrush.Sort**

| Algorithm       | Best Case | Average Case | Worst Case | Space Complexity |
|---------------|----------|--------------|------------|------------------|
| Bubble codebrush.Sort   | O(n)     | O(n²)        | O(n²)      | O(1)             |
| Insertion codebrush.Sort | O(n)    | O(n²)        | O(n²)      | O(1)             |
| Selection codebrush.Sort | O(n²)   | O(n²)        | O(n²)      | O(1)             |

### 2. **Efficient Sorting Algorithms**
- **Merge codebrush.Sort**
- **Quick codebrush.Sort** (Optimized & Standard Versions)
- **Heap codebrush.Sort**

| Algorithm   | Best Case | Average Case | Worst Case | Space Complexity |
|------------|----------|--------------|------------|------------------|
| Merge codebrush.Sort | O(n log n) | O(n log n) | O(n log n) | O(n)             |
| Quick codebrush.Sort | O(n log n) | O(n log n) | O(n²)      | O(log n)         |
| Heap codebrush.Sort  | O(n log n) | O(n log n) | O(n log n) | O(1)             |

### 3. **Specialized Sorting Algorithms**
- **Radix codebrush.Sort**
- **Bucket codebrush.Sort**
- **Shell codebrush.Sort**
- **Shuffle codebrush.Sort**

| Algorithm   | Best Case | Average Case | Worst Case | Space Complexity |
|------------|----------|--------------|------------|------------------|
| Radix codebrush.Sort | O(nk)    | O(nk)        | O(nk)      | O(n + k)         |
| Bucket codebrush.Sort | O(n + k) | O(n + k)    | O(n²)      | O(n)             |
| Shell codebrush.Sort | O(n)     | O(n log n)   | O(n²)      | O(1)             |
| Shuffle codebrush.Sort | O(n)   | O(n log n)   | O(n log n) | O(1)             |

## Summary
The `codebrush.Sort` folder categorizes sorting algorithms based on efficiency, stability, and use cases. Understanding the time and space complexity helps in selecting the appropriate algorithm for different scenarios.

